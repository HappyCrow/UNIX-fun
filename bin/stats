#!/usr/bin/env ocamlscript
Ocaml.packs := ["batteries";"minicli"]
--
(* read one float per line from stdin (until End_of_file);
   then output whatever descriptive statistics the user asked for *)

module CLI = Minicli.CLI

let compose f g x =
  f (g x)

open Printf

module L = struct

  include BatList

  let to_string to_str l =
    let buff = Buffer.create 80 in
    Buffer.add_char buff '[';
    iteri (fun i x ->
        if i > 0 then Buffer.add_char buff ';';
        Buffer.add_string buff (to_str x);
      ) l;
    Buffer.add_char buff ']';
    Buffer.contents buff
end

type stat = Single of float
          | Many of float list

let read_stat = function
  | Single x -> x
  | Many _ -> assert(false)

let str_of_stat = function
  | Single x -> sprintf "%f" x
  | Many xs -> L.to_string (sprintf "%f") xs

let card l =
  Single (float (L.length l))

let average (l: float list): stat =
  let n = read_stat (card l) in
  Single ((L.fsum l) /. n)

let stddev (l: float list): stat =
  let sqr x = x *. x in
  let n, sx, sx2 =
    List.fold_left
      (fun (n, sx, sx2) x -> succ n, sx +. x, sx2 +. sqr x)
      (0, 0., 0.) l
  in
  Single (sqrt ((sx2 -. sqr sx /. float n) /. float n))

(* number of stddevs away from the mean *)
let zscore (l: float list): stat =
  let avg = read_stat (average l) in
  let std = read_stat (stddev l) in
  Many (L.map (fun x -> (x -. avg) /. std) l)

let median (l: float list): stat =
  let xs = Array.of_list l in
  Array.sort BatFloat.compare xs;
  let n = Array.length xs in
  if n mod 2 = 1 then
    Single xs.(n/2)
  else
    Single (0.5 *. (xs.(n/2) +. xs.(n/2 - 1)))

(* Median Absolute Deviation *)
let mad l =
  let med = read_stat (median l) in
  let abs_devs = L.map (fun x -> abs_float (x -. med)) l in
  Single (read_stat (median abs_devs))
(*$T mad
  mad (map float [1;1;2;2;4;6;9]) = Single 1.0
*)

let single x =
  Single x

let op_of_str = function
  | "min" -> compose single L.min
  | "max" -> compose single L.max
  | "avg" -> average
  | "med" -> median
  | "stddev" -> stddev
  | "zscore" -> zscore
  | "mad" -> mad
  | "card" -> card
  | other -> failwith ("Stats.op_of_str: unsupported op: " ^ other)

let () =
  let argc, args = CLI.init () in
  if argc = 1 then
    begin
      eprintf "usage:\n  \
               %s -ops {card[,min[,max[,avg[,med[,stddev[,zscore[,mad]...}\n  \
        [-d <string>]: field delimiter string\n  \
        [-f <int>]: field number (default=1)\n \\
        [-g <int>]: group by field number (default=None)\n"
        Sys.argv.(0);
      exit 1
    end;
  let required_operations = CLI.get_string ["-ops"] args in
  let delim_str = CLI.get_string_opt ["-d"] args in
  let field_num = CLI.get_int_opt ["-f"] args in
  let group_by_field = CLI.get_int_opt ["-g"] args in
  CLI.finalize();
  let operations = BatString.split_on_char ',' required_operations in
  let ops = L.map op_of_str operations in
  let floats, exn =
    match delim_str, field_num, group_by_field with
    | (None, None, None) ->
      L.unfold_exc (fun () ->
          let line = BatString.strip (input_line stdin) in
          try float_of_string line
          with Failure msg -> failwith (sprintf "%s: %s" msg line))
    | _ -> failwith "not implemented yet"
  in
  if exn <> End_of_file then raise exn;
  L.iteri (fun i op ->
      let res = op floats in
      let str = str_of_stat res in
      if i = 0 then
        printf "%s" str
      else
        printf " %s" str
    ) ops;
  printf "\n"
